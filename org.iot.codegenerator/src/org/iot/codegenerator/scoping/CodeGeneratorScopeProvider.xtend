/*
 * generated by Xtext 2.20.0
 */
package org.iot.codegenerator.scoping

import java.util.Collections
import java.util.HashSet
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.iot.codegenerator.codeGenerator.Board
import org.iot.codegenerator.codeGenerator.Cloud
import org.iot.codegenerator.codeGenerator.CodeGeneratorPackage
import org.iot.codegenerator.codeGenerator.Data
import org.iot.codegenerator.codeGenerator.DeviceConf
import org.iot.codegenerator.codeGenerator.Fog
import org.iot.codegenerator.codeGenerator.ModifyPipeline
import org.iot.codegenerator.codeGenerator.Pipeline
import org.iot.codegenerator.codeGenerator.Provider

import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension org.iot.codegenerator.util.InheritanceUtil.*

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class CodeGeneratorScopeProvider extends AbstractCodeGeneratorScopeProvider {

	override getScope(EObject context, EReference reference) {
		val codeGen = CodeGeneratorPackage.eINSTANCE
		switch (reference) {
			case codeGen.reference_Variable:
				context.variableScope
			case codeGen.transformationOut_Source,
			case codeGen.sensorDataOut_Source:
				context.variablesScope
			case codeGen.transformation_Provider:
				context.transformationProvidersScope
			case codeGen.channelOut_Channel,
			case codeGen.board_Inputs:
				context.channelsScope
			default:
				super.getScope(context, reference)
		}
	}
	
	def private IScope getVariableScope(EObject context) {
		val pipelineContainer = context.getContainerOfType(Pipeline)?.eContainer()?.getContainerOfType(ModifyPipeline)
		if (pipelineContainer !== null) {
			return Scopes.scopeFor((Collections.singleton(pipelineContainer.output)))
		} 
		val providerContainer = context.eContainer.getContainerOfType(Provider)
		if (providerContainer !== null && providerContainer.variables !== null){
			return Scopes.scopeFor(providerContainer.variables.ids)
		}
		return IScope.NULLSCOPE
	}
	
	def private IScope getVariablesScope(EObject context) {
		Scopes.scopeFor(Collections.singleton(context.getContainerOfType(Provider).variables))
	}

	def private IScope getTransformationProvidersScope(EObject context) {
		var fog = context.getContainerOfType(Fog)
		var cloud = context.getContainerOfType(Cloud)
		var deviceConf = fog?.getContainerOfType(DeviceConf)
		val datas = new HashSet<Data>
		if (deviceConf === null){
			deviceConf = cloud?.getContainerOfType(DeviceConf)
			if (fog === null){
				fog = deviceConf.fog.last
			}
		}
		if (fog !== null && cloud !== null){
			fog.transformations.forEach[transformation | datas.addAll(transformation.datas)]
		}
		val board = deviceConf?.board?.getObjectByType(CodeGeneratorPackage.eINSTANCE.concreteBoard)
		
		if (board !== null){
			val sensors = (board as Board).inheritedSensors
			sensors.forEach[sensor | datas.addAll(sensor.datas)]
			val scope = Scopes.scopeFor(datas)

			if(scope !== null){
				return scope
			}
		}
		
		return IScope.NULLSCOPE
	}
	
	def private IScope getChannelsScope(EObject context){
		if (context instanceof Board){
			return context.channelsScope
		}
		val board = context.eContainer.getContainerOfType(Board)
		if (board !== null){
			return board.channelsScope
		}
		return IScope.NULLSCOPE
	}
	
	def private IScope channelsScope(Board board){
		val channels = board.inheritedChannels
		if (!channels.empty){
			return Scopes.scopeFor(channels)			
		}
		return IScope.NULLSCOPE
	}

}
